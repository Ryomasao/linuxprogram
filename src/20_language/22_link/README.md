# 分割コンパイル復習

とてもいい資料。prog05 の static 変数も目を通しておくこと。
http://www.cc.kyoto-su.ac.jp/~hxm/cstext/prog06.html

コンパイルの流れは、プリプロセス → コンパイル → リンクっていう流れね！

ex1.h

```c
#define NUMBER 5
```

ex1.c

```c
#include <stdio.h>

#include "ex1.h"

int f(int);

int x = NUMBER;

int main(void) {
  printf("x=%d\n", x);
  printf("f(x)=%d\n", f(x));
  return 0;
}
```

## プリプロセス

下記を実行すると

```
$ gcc -E ex1.c
```

```c
int f(int);

// #define NUMBER が展開される
int x = 5;

int main(void) {
  printf("x=%d\n", x);
  printf("f(x)=%d\n", f(x));
  re
```

## コンパイル

`c`オプションで、リンクは行わなずに、コンパイルだけを行うことができる。

```
// オブジェクトファイルex1.oが作成される
$ gcc -c ex1.c
// オブジェクトファイルf.oが作成される
$ gcc -c f.c
// オブジェクトファイルから、実行ファイルex1を作成する
$ gcc -o ex1 ex1.o f.o
```

## グローバル変数

### 基本

~~グローバル変数はファイル(モジュール)スコープ。~~
ではない！グローバル変数はプログラム全体のスコープ。
なので、同じ名前の変数があると duplicate でコンパイルが通らなくなる。

が、しかし、これを理解する上で、定義と宣言を理解する必要がある。

```c
// これは宣言。名前を宣言しているだけで、int分のメモリの割り当ては行われていない。
int a;
```

```c
// これは、定義。名前も宣言しているし、int分のメモリ割り当てが行われている。
int a = 0;
```

ここで大事なことは、宣言は何度書いてもいいということ。

これはコンパイルエラーにはならない。

```c
int b;
int b;
int b = 2;
int b;
int b;
```

一方、定義は一回しか書けない。

```c
int b;
int b;
int b = 2;
int b = 2;
int b;
int b;
```

このことから、ヘッダファイルに変数の宣言はいいけど、定義は書くべきじゃない、ということが理解できる。

### 変数をモジュール間で共有する

定義したグローバル変数は、別のモジュールで宣言することで参照することができる。

```c
// 変数を定義
int a = 1;
int main() {
  // 省略
}

```

f.c

```c
// これが大事。変数を宣言する。
int a;

int f() {
  // 1が表示される
  printf(a);
}
```

しかし、これは暗黙の extern がついていると理解しておく必要がある。
本来、別モジュールのグローバル変数を参照するのであれば、以下の通り、extern をつける必要がある。

f.c

```c
// 正しい方法
extern int a;

int f() {
  // 1が表示される
  printf(a);
}
```

extern をつけることで、この変数は、定義ではなくって宣言なんだよ！っていうのが明確になる。
え、`int a;`だけだったら宣言確定じゃないの？って思うんだけど、`int a`だけ書いてあって、他で定義しているものがなければ、コンパイラは、`int a = 0`として定義してしまう。

つまり、

```c
//これだけみても、これが宣言なのか定義なのかはわからないってこと。
int a;

// コンパイラはグローバル変数全体をみて、int a = xxx がなければ、int aを定義と捉える。
// int a = xxxがあれば、int aは宣言と捉える。
// extern int aは絶対に宣言扱いになる。
// これにより、extern int a にしとくと、定義がない場合はコンパイルエラーになる。
```
